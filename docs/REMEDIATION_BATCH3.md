# OpeningIQ — Batch 3 Remediation Plan

This document is the implementation spec for all bugs identified in the Batch 3 audit. These are all already fixed in the working tree — this doc exists so you can review exactly what changed and why before committing.

---

## Fix 1 — Board orientation inverted for all openings

**Priority: High**

**File:** `src/components/BoardSection.tsx`

**The problem:** White openings start with black pieces on the bottom. Black openings start with white pieces on the bottom. The player has to press "Flip Board" at the start of every game to get the correct view.

**Root cause:** The `boardOrientation` ternary had its return values swapped.

```ts
// BEFORE (wrong — returns 'black' when White player, unflipped)
const boardOrientation =
  (playerColor === 'white') !== (boardFlipped ?? false) ? 'black' : 'white'

// AFTER (correct — returns 'white' when White player, unflipped)
const boardOrientation =
  (playerColor === 'white') !== (boardFlipped ?? false) ? 'white' : 'black'
```

**How the logic works:**
- `playerColor === 'white'` is `true` for White openings
- `boardFlipped` is `false` by default
- `true !== false` → `true` → returns first branch
- First branch should be `'white'` (White pieces on bottom = standard view)
- With flip: `true !== true` → `false` → returns `'black'` (flipped view) ✅

---

## Fix 2 — Opening exits to free play after first move (systemic, 100% repro rate)

**Priority: Critical**

**The problem:** Every opening immediately shows "You've left the book. The engine is now playing at your selected ELO." after the player's very first move, regardless of whether that move is in the theory tree.

**Three compounding root causes, all fixed:**

---

### Fix 2a — Wrong FENs in all opening JSON files (primary cause)

**Files:** `src/data/openings/italian-game.json`, `ruy-lopez.json`, `london-system.json`, `queens-gambit.json`, `caro-kann.json`, `french-defense.json`, `kings-indian.json`, `pirc-defense.json`, `scandinavian.json`, `sicilian-najdorf.json`

**Root cause:** Every FEN string in every opening JSON file was generated with a tool that always writes the en passant target square (e.g. `KQkq e3 0 1`). Chess.js only writes an en passant square when an adjacent enemy pawn is actually present to capture. In all early opening positions this is never true, so chess.js produces `KQkq - 0 1` instead.

The `OpeningTree` builds a `fenIndex` keyed on those wrong FEN strings. When the game plays moves through chess.js and calls `getNode(fen)`, the lookup always fails — the index has `"...KQkq e3 0 1"` but chess.js gave us `"...KQkq - 0 1"`. `getNode` returns `null`, `inTheory` is `false`, `setPhase('free')` fires immediately.

Additionally, several files had wrong piece positions in deeper nodes (King's Indian had the e4 pawn on the wrong square; Caro-Kann had wrong piece positions after captures; Scandinavian had wrong half-move clocks).

**Fix:** All FENs were regenerated by replaying every move sequence through chess.js from the root position. The script below was used — do not re-run it, FENs are already correct.

```js
// Script used to regenerate (already applied — for reference only)
const { Chess } = require('chess.js')
const fs = require('fs')
const path = require('path')

const dir = './src/data/openings'
const files = fs.readdirSync(dir).filter(f => f.endsWith('.json'))

function fixNode(node, chess) {
  const move = chess.move(node.san)
  if (!move) return node
  node.fen = chess.fen()
  if (node.children?.length) {
    node.children = node.children.map(child => {
      const childChess = new Chess(chess.fen())
      const fixed = fixNode(child, childChess)
      return fixed
    })
  }
  chess.undo()
  return node
}

for (const file of files) {
  if (file === 'index.ts') continue
  const filePath = path.join(dir, file)
  const data = JSON.parse(fs.readFileSync(filePath, 'utf8'))
  data.rootFen = new Chess(data.rootFen).fen()
  data.moves = data.moves.map(node => {
    const chess = new Chess(data.rootFen)
    return fixNode(node, chess)
  })
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2))
}
```

**Key corrections per file:**

| File | Issues fixed |
|---|---|
| `italian-game.json` | `e4` node FEN: `e3` → `-`; `e5` node: `e6` → `-`; `c3`/`Nc3`/`b4` move counters wrong |
| `ruy-lopez.json` | `e4` node: `e3` → `-`; `e5` node: `e6` → `-`; `Bc5` piece position wrong |
| `london-system.json` | `d4` node: `d3` → `-`; `d5` node: `d6` → `-` |
| `queens-gambit.json` | `d4`/`d5`/`c4` nodes: all had en passant squares, all removed |
| `caro-kann.json` | `rootFen`: `e3` → `-`; `dxe4` and `Nxe4` piece positions wrong; `Ng3` piece position wrong |
| `french-defense.json` | `rootFen`: `e3` → `-`; `d4`/`d5` nodes: `d3`/`d6` → `-` |
| `kings-indian.json` | `rootFen`: `d3` → `-`; `e4` node had pawn on wrong square (f4 vs e4); all deeper nodes cascaded wrong |
| `pirc-defense.json` | `rootFen`: `e3` → `-`; `d4` node: `d3` → `-` |
| `scandinavian.json` | `rootFen`: `e3` → `-`; `d4`/`Nf6`/`Nf3` nodes: wrong en passant + wrong half-move clocks |
| `sicilian-najdorf.json` | `rootFen`: `e3` → `-`; `c5` node: `c6` → `-`; `d4` node: piece position wrong |

---

### Fix 2b — `getNode()` synthetic root node missing `children`

**File:** `src/services/OpeningTree.ts`

**Root cause:** `getNode()` returns a synthetic node when the queried FEN matches `rootFen`. That synthetic node was missing the `children` array:

```ts
// BEFORE (missing children)
if (this.rootFen && fen === this.rootFen) {
  return {
    san: '',
    fen: this.rootFen,
    engineResponses: this.rootResponses,
    responseWeights: this.rootWeights,
    // no children!
  }
}
```

When `handleMove` called `getChild(node, moveResult.san)`, it checks `node.children` first. Without `children`, it hits the fallback `if (this.rootFen && node.fen === this.rootFen)` path — but that only reaches this because `getChild` is called on the node returned by `getNode`, not directly on the class instance. The fallback `this.root.find(...)` does work, but only in `getChild`. The problem is `getChild`'s first line: `if (node.children) return node.children.find(...)` — `node.children` being `undefined` is falsy, so it falls through. With no `rootFen` match in `getChild` either (because the synthetic node's fen equals rootFen but the condition checks `this.rootFen && node.fen === this.rootFen` which would actually work)... this compounds with Fix 2a: if FENs were wrong, `getNode` never returned the synthetic node at all, so this bug was masked.

```ts
// AFTER (includes children)
if (this.rootFen && fen === this.rootFen) {
  return {
    san: '',
    fen: this.rootFen,
    engineResponses: this.rootResponses,
    responseWeights: this.rootWeights,
    children: this.root,   // ← added
  }
}
```

This matches what `getRootNode()` already returns and makes `getChild` work correctly via the `node.children` path.

---

### Fix 2c — `OpeningTree` built asynchronously in `useEffect`

**File:** `src/components/GameView.tsx`

**Root cause:** The `OpeningTree` instance was created inside a `useEffect` watching `openingId`:

```ts
// BEFORE (async — fires after render, tree is null on first move)
useEffect(() => {
  if (openingId) {
    const data = openings.find((o) => o.id === openingId)
    if (data) openingTreeRef.current = new OpeningTree(data)
  }
}, [openingId])
```

React `useEffect` runs **after** the component renders and paints. The board is immediately interactive. If the player moves before the effect fires (which in practice is always possible), `openingTreeRef.current` is `null`. In `handleMove`, `tree` is `null`, the theory check is skipped, `inTheory = false`, and `setPhase('free')` fires.

```ts
// AFTER (synchronous — tree is ready before first render completes)
const loadedOpeningIdRef = useRef<string | null>(null)

// During render body (not in a useEffect):
if (openingId && loadedOpeningIdRef.current !== openingId) {
  const data = openings.find((o) => o.id === openingId)
  if (data) {
    openingTreeRef.current = new OpeningTree(data)
    loadedOpeningIdRef.current = openingId
  }
}
```

`loadedOpeningIdRef` tracks which opening is currently loaded so the tree is only rebuilt when the opening actually changes, not on every render.

---

### Fix 2d — Stale `phase` closure in `handleMove`

**File:** `src/components/GameView.tsx`

**Root cause:** `handleMove` is a `useCallback` with `phase` in its dependency array. The closed-over `phase` value can be stale between renders in edge cases — particularly right after a new game starts.

```ts
// BEFORE (reads phase from potentially stale closure)
let inTheory = false
if (tree && phase === 'opening') {

// AFTER (reads phase fresh from store at call time)
let inTheory = false
const currentPhaseBefore = useGameStore.getState().phase
if (tree && currentPhaseBefore === 'opening') {
```

This matches the pattern already used elsewhere in `handleMove` for reading `phase` after the engine move (`const currentPhase = useGameStore.getState().phase` on line 189).

---

## Files changed in Batch 3

| File | Change |
|---|---|
| `src/components/BoardSection.tsx` | Swap `'black'`/`'white'` in boardOrientation ternary |
| `src/services/OpeningTree.ts` | Add `children: this.root` to synthetic root node in `getNode()` |
| `src/components/GameView.tsx` | Build tree synchronously; read phase from store in handleMove |
| `src/data/openings/italian-game.json` | Regenerated all FENs |
| `src/data/openings/ruy-lopez.json` | Regenerated all FENs |
| `src/data/openings/london-system.json` | Regenerated all FENs |
| `src/data/openings/queens-gambit.json` | Regenerated all FENs |
| `src/data/openings/caro-kann.json` | Regenerated all FENs + rootFen |
| `src/data/openings/french-defense.json` | Regenerated all FENs + rootFen |
| `src/data/openings/kings-indian.json` | Regenerated all FENs + rootFen |
| `src/data/openings/pirc-defense.json` | Regenerated all FENs + rootFen |
| `src/data/openings/scandinavian.json` | Regenerated all FENs + rootFen |
| `src/data/openings/sicilian-najdorf.json` | Regenerated all FENs + rootFen |
| `docs/UPDATE_LOG.md` | Batch 3 entry added |

---

## Commit message

```
Fix systemic FEN mismatch in all opening JSONs + three compounding book-exit bugs

- All 10 opening JSON files: regenerated FENs by replaying moves through
  chess.js. All had wrong en passant target squares (e.g. KQkq e3 0 1)
  that chess.js never produces in these positions. fenIndex lookups were
  failing on every move, causing immediate exit to free play.
- OpeningTree.getNode(): add children to synthetic root node so getChild()
  resolves the first player move correctly
- GameView: build OpeningTree synchronously during render (was in useEffect,
  so tree was null when player made first move)
- GameView.handleMove: read phase from store at call time, not stale closure
- BoardSection: fix boardOrientation ternary (values were swapped)
```
